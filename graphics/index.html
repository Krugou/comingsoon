<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coming Soon - NodeCG Graphics</title>
  <meta name="description" content="Coming Soon 3D Graphics for NodeCG">

  <!-- Add Lexend Mega font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend+Mega:wght@100..900&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #242D38;
      font-family: 'Lexend Mega', sans-serif;
    }

    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Fallback if 3D doesn't work */
    #fallback-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: 'Lexend Mega', sans-serif;
      text-align: center;
      z-index: -1;
    }

    #fallback-container h1 {
      font-size: 3rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #002ea2;
    }

    #fallback-container p {
      font-size: 1.5rem;
      color: #f7fafc;
      font-weight: 500;
    }

    /* Loading indicator */
    #loading-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f7fafc;
      font-family: 'Lexend Mega', sans-serif;
      font-size: 1.5rem;
      text-align: center;
      z-index: 100;
    }

    /* Added optional spinner (mirrors root) */
    .spinner {
      margin: 20px auto;
      width: 50px;
      height: 50px;
      border: 3px solid rgba(122, 152, 251, 0.3);
      border-radius: 50%;
      border-top-color: #002ea2;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>

  <!-- Added import map for three -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <!-- Loading indicator -->
  <div id="loading-indicator">Loading 3D Scene...</div>

  <!-- 3D Scene Container -->
  <div id="scene-container"></div>

  <!-- Fallback for browsers without WebGL -->
  <div id="fallback-container">
    <h1 id="fallback-title">EXAMPLE SITE</h1>
    <p id="fallback-subtitle">COMING SOON 2025</p>
    <p id="fallback-attribution" style="margin-top: 2rem; font-size: 0.875rem; color: #637786;">Example Company &
      Partner Organization</p>
  </div>

  <script type="module">
    /* Replaced ComingSoonScene usage with inline logic parallel to /index.html */
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    const container = document.getElementById( 'scene-container' );
    const fallback = document.getElementById( 'fallback-container' );
    const loadingIndicator = document.getElementById( 'loading-indicator' );

    // Default configuration (mirrors root index.html)
    const defaultConfig = {
      title: { text: "EXAMPLE SITE", color: 0x002ea2, size: 1.2, yPos: 3, enabled: true },
      subtitle: { text: "COMING SOON 2025", color: 0xf7fafc, size: 0.8, yPos: -2, enabled: true },
      attribution: { text: "Example Company & Partner Organization", color: 0x637786, size: 0.4, yPos: -5.5, enabled: true },
      background: { color: 0x242D38, particleCount: 1000, particleColor: 0xf7fafc, particleSize: 0.1, particleOpacity: 0.6 },
      animation: { explosionDuration: 6000, explosionStrength: 15, rotationStrength: 3 }
    };

    const parseColor = v => {
      if ( !v ) return null;
      v = v.replace( /^#/, '' );
      return /^[0-9A-F]{6}$/i.test( v ) ? parseInt( v, 16 ) : null;
    };
    const parseNumber = ( v, d ) => {
      if ( !v ) return d;
      const n = parseFloat( v );
      return isNaN( n ) ? d : n;
    };

    const getCustomConfig = () => {
      const params = new URLSearchParams( window.location.search );
      const cfg = JSON.parse( JSON.stringify( defaultConfig ) );
      [ 'title', 'subtitle', 'attribution' ].forEach( key => {
        if ( params.has( key ) ) {
          cfg[ key ].text = params.get( key ).substring( 0, key === 'attribution' ? 100 : 50 );
        }
        const c = parseColor( params.get( key + 'Color' ) ); if ( c !== null ) cfg[ key ].color = c;
        cfg[ key ].size = parseNumber( params.get( key + 'Size' ), cfg[ key ].size );
        cfg[ key ].yPos = parseNumber( params.get( key + 'Y' ), cfg[ key ].yPos );
      } );
      const bgc = parseColor( params.get( 'bgColor' ) ); if ( bgc !== null ) cfg.background.color = bgc;
      cfg.background.particleCount = parseNumber( params.get( 'particleCount' ), cfg.background.particleCount );
      const pc = parseColor( params.get( 'particleColor' ) ); if ( pc !== null ) cfg.background.particleColor = pc;
      cfg.background.particleSize = parseNumber( params.get( 'particleSize' ), cfg.background.particleSize );
      cfg.background.particleOpacity = parseNumber( params.get( 'particleOpacity' ), cfg.background.particleOpacity );
      cfg.animation.explosionDuration = parseNumber( params.get( 'explosionDuration' ), cfg.animation.explosionDuration );
      cfg.animation.explosionStrength = parseNumber( params.get( 'explosionStrength' ), cfg.animation.explosionStrength );
      cfg.animation.rotationStrength = parseNumber( params.get( 'rotationStrength' ), cfg.animation.rotationStrength );
      // ensure enabled defaults to true if absent
      return cfg;
    };

    let config = getCustomConfig();

    // Update document + fallback
    document.title = `${ config.title.text } - ${ config.subtitle.text }`;
    const metaDesc = document.querySelector( 'meta[name="description"]' );
    if ( metaDesc ) metaDesc.setAttribute( 'content', `${ config.title.text } - ${ config.subtitle.text }` );
    const setHex = c => '#' + c.toString( 16 ).padStart( 6, '0' );
    document.getElementById( 'fallback-title' ).textContent = config.title.text;
    document.getElementById( 'fallback-subtitle' ).textContent = config.subtitle.text;
    document.getElementById( 'fallback-attribution' ).textContent = config.attribution.text;
    document.getElementById( 'fallback-title' ).style.color = setHex( config.title.color );
    document.getElementById( 'fallback-subtitle' ).style.color = setHex( config.subtitle.color );
    document.getElementById( 'fallback-attribution' ).style.color = setHex( config.attribution.color );
    document.body.style.backgroundColor = setHex( config.background.color );

    class SceneError extends Error { constructor ( msg ) { super( msg ); this.name = 'SceneError'; } }

    let scene, camera, renderer, particles;
    let textGroups = [];
    let letterMeshes = [];
    const clock = new THREE.Clock();

    const animState = {
      exploding: false,
      startTime: 0,
      duration: config.animation.explosionDuration,
      meshes: [],
      originalPositions: [],
      originalRotations: []
    };

    // Text creation (individual letters for explosion)
    const createTextGeometry = async ( scene, text, color, size, yPos ) => {
      const fontLoader = new FontLoader();
      const font = await new Promise( ( res, rej ) => {
        fontLoader.load( 'https://unpkg.com/three@0.168.0/examples/fonts/gentilis_bold.typeface.json', res, undefined, rej );
      } );

      const group = new THREE.Group();
      const letterGroups = [];
      const letterSizes = [];
      const materialBase = new THREE.MeshStandardMaterial( {
        color, metalness: 0.3, roughness: 0.7, emissive: color, emissiveIntensity: 0.2, flatShading: true
      } );

      let totalWidth = 0;
      const geometries = [];
      for ( let i = 0; i < text.length; i++ ) {
        const ch = text[ i ];
        if ( ch === ' ' ) {
          geometries.push( null );
          letterSizes.push( size * 0.6 );
          totalWidth += size * 0.6;
          continue;
        }
        const geo = new TextGeometry( ch, {
          font, size, height: size * 0.2, curveSegments: 5,
          bevelEnabled: true, bevelThickness: size * 0.03,
          bevelSize: size * 0.01, bevelOffset: 0, bevelSegments: 3
        } );
        geo.computeBoundingBox();
        const w = geo.boundingBox.max.x - geo.boundingBox.min.x;
        const letterWidth = w + size * 0.1;
        letterSizes.push( letterWidth );
        totalWidth += letterWidth;
        geometries.push( geo );
      }
      let currentX = -totalWidth / 2;
      for ( let i = 0; i < text.length; i++ ) {
        if ( text[ i ] === ' ' ) {
          currentX += letterSizes[ i ];
          continue;
        }
        const geo = geometries[ i ];
        const mesh = new THREE.Mesh( geo, materialBase.clone() );
        const letterGroup = new THREE.Group();
        letterGroup.position.set( currentX, yPos, 0 );
        mesh.position.set( 0, 0, 0 );
        letterGroup.add( mesh );
        letterGroup.userData = {
          isLetter: true,
          originalPosition: { x: currentX, y: yPos, z: 0 },
          originalRotation: { x: 0, y: 0, z: 0 }
        };
        group.add( letterGroup );
        letterGroups.push( letterGroup );
        currentX += letterSizes[ i ];
      }
      scene.add( group );
      return { group, meshes: letterGroups };
    };

    const createCubeTextFallback = ( scene, text, color, size, yPos ) => {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial( {
        color, metalness: 0.3, roughness: 0.7, emissive: color, emissiveIntensity: 0.2
      } );
      const spacing = size * 1.2;
      const letters = text.split( '' ).filter( c => c !== '' ).length;
      let xPos = -( letters * spacing ) / 2 + spacing / 2;
      const meshes = [];
      for ( const ch of text ) {
        if ( ch === ' ' ) { xPos += spacing; continue; }
        const cube = new THREE.Mesh( new THREE.BoxGeometry( size, size, size * 0.5 ), mat.clone() );
        cube.position.set( xPos, yPos, 0 );
        cube.userData = {
          isLetter: true,
          originalPosition: { x: xPos, y: yPos, z: 0 },
          originalRotation: { x: 0, y: 0, z: 0 }
        };
        group.add( cube );
        meshes.push( cube );
        xPos += spacing;
      }
      scene.add( group );
      return { group, meshes };
    };

    const setEnabledFallbackVisibility = () => {
      const tEl = document.getElementById( 'fallback-title' );
      const sEl = document.getElementById( 'fallback-subtitle' );
      const aEl = document.getElementById( 'fallback-attribution' );
      if ( tEl ) tEl.style.display = ( config.title.enabled === false ) ? 'none' : '';
      if ( sEl ) sEl.style.display = ( config.subtitle.enabled === false ) ? 'none' : '';
      if ( aEl ) aEl.style.display = ( config.attribution.enabled === false ) ? 'none' : '';
    };

    const createText = async () => {
      // Remove existing
      textGroups.forEach( g => {
        scene.remove( g );
        g.traverse( o => {
          if ( o.geometry ) o.geometry.dispose();
          if ( o.material ) o.material.dispose();
        } );
      } );
      textGroups = [];
      letterMeshes = [];

      const sets = [];
      const keys = [ 'title', 'subtitle', 'attribution' ];
      for ( const key of keys ) {
        const part = config[ key ];
        if ( part.enabled === false ) continue;          // skip disabled
        if ( !part.text || part.text.length === 0 ) continue; // allow empty (skip rendering)
        try {
          sets.push( await createTextGeometry(
            scene,
            config[ key ].text,
            config[ key ].color,
            config[ key ].size,
            config[ key ].yPos
          ) );
        } catch ( e ) {
          console.warn( 'TextGeometry failed for', key, 'fallback to cubes', e );
          sets.push( createCubeTextFallback(
            scene,
            config[ key ].text,
            config[ key ].color,
            config[ key ].size,
            config[ key ].yPos
          ) );
        }
      }
      sets.forEach( s => {
        textGroups.push( s.group );
        letterMeshes.push( ...s.meshes );
      } );
      animState.meshes = letterMeshes;
      saveOriginalPositions();
    };

    const createParticles = () => {
      if ( particles ) {
        scene.remove( particles );
        particles.geometry.dispose();
        particles.material.dispose();
      }
      const count = config.background.particleCount;
      const positions = new Float32Array( count * 3 );
      for ( let i = 0; i < count; i++ ) {
        positions[ i * 3 ] = ( Math.random() - 0.5 ) * 100;
        positions[ i * 3 + 1 ] = ( Math.random() - 0.5 ) * 100;
        positions[ i * 3 + 2 ] = ( Math.random() - 0.5 ) * 100;
      }
      const geom = new THREE.BufferGeometry();
      geom.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
      const mat = new THREE.PointsMaterial( {
        color: config.background.particleColor,
        size: config.background.particleSize,
        transparent: true,
        opacity: config.background.particleOpacity
      } );
      particles = new THREE.Points( geom, mat );
      scene.add( particles );
    };

    const saveOriginalPositions = () => {
      animState.originalPositions = [];
      animState.originalRotations = [];
      animState.meshes.forEach( m => {
        if ( m.userData?.isLetter ) {
          animState.originalPositions.push( { object: m, position: m.position.clone() } );
          animState.originalRotations.push( { object: m, rotation: { x: m.rotation.x, y: m.rotation.y, z: m.rotation.z } } );
        }
      } );
    };

    const triggerExplosion = () => {
      if ( animState.exploding ) return;
      animState.exploding = true;
      animState.startTime = Date.now();
      animState.duration = config.animation.explosionDuration;
      const strength = config.animation.explosionStrength;
      const rStrength = config.animation.rotationStrength;
      animState.meshes.forEach( m => {
        m.userData.velocity = {
          x: ( Math.random() - 0.5 ) * strength,
          y: ( Math.random() - 0.5 ) * strength,
          z: ( Math.random() - 0.5 ) * strength
        };
        m.userData.rotationVelocity = {
          x: ( Math.random() - 0.5 ) * rStrength,
          y: ( Math.random() - 0.5 ) * rStrength,
          z: ( Math.random() - 0.5 ) * rStrength
        };
      } );
      // Simple synth
      try {
        const ctx = new ( window.AudioContext || window.webkitAudioContext )();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime( 250, ctx.currentTime );
        osc.frequency.exponentialRampToValueAtTime( 0.01, ctx.currentTime + 1.5 );
        gain.gain.setValueAtTime( 0.1, ctx.currentTime );
        gain.gain.exponentialRampToValueAtTime( 0.01, ctx.currentTime + 1.5 );
        osc.connect( gain ); gain.connect( ctx.destination );
        osc.start(); osc.stop( ctx.currentTime + 1.5 );
      } catch ( _ ) { }
      setTimeout( () => { animState.exploding = false; }, animState.duration );
    };

    const showFallback = () => {
      fallback.style.zIndex = '1';
      loadingIndicator.style.display = 'none';
    };

    const handleResize = () => {
      if ( !camera || !renderer ) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
    };

    const handleClick = e => { e && e.preventDefault && e.preventDefault(); triggerExplosion(); };
    const handleKeydown = _ => triggerExplosion();

    let animationId;
    const animate = () => {
      animationId = requestAnimationFrame( animate );
      const delta = clock.getDelta();

      if ( !animState.exploding ) {
        textGroups.forEach( g => {
          g.rotation.y = Math.sin( Date.now() * 0.001 ) * 0.1;
        } );
      }
      if ( particles ) {
        particles.rotation.y += 0.0005;
        particles.rotation.z += 0.0002;
      }
      if ( animState.exploding ) {
        animState.meshes.forEach( m => {
          m.position.x += m.userData.velocity.x * delta;
          m.position.y += m.userData.velocity.y * delta;
          m.position.z += m.userData.velocity.z * delta;
          m.rotation.x += m.userData.rotationVelocity.x * delta;
          m.rotation.y += m.userData.rotationVelocity.y * delta;
          m.rotation.z += m.userData.rotationVelocity.z * delta;
        } );
      } else if ( Date.now() - animState.startTime < animState.duration * 1.5 ) {
        const elapsedReturn = Date.now() - animState.startTime - animState.duration;
        const returnProgress = Math.min( elapsedReturn / ( animState.duration * 0.5 ), 1 );
        const easing = 1 - Math.pow( 1 - returnProgress, 3 );
        animState.originalPositions.forEach( ( item, i ) => {
          const m = item.object;
          const op = item.position;
          const or = animState.originalRotations[ i ].rotation;
          m.position.x += ( op.x - m.position.x ) * easing * 0.1;
          m.position.y += ( op.y - m.position.y ) * easing * 0.1;
          m.position.z += ( op.z - m.position.z ) * easing * 0.1;
          m.rotation.x += ( or.x - m.rotation.x ) * easing * 0.1;
          m.rotation.y += ( or.y - m.rotation.y ) * easing * 0.1;
          m.rotation.z += ( or.z - m.rotation.z ) * easing * 0.1;
          if ( returnProgress > 0.95 ) {
            m.position.set( op.x, op.y, op.z );
            m.rotation.set( or.x, or.y, or.z );
          }
        } );
        if ( returnProgress > 0.99 ) {
          textGroups.forEach( g => { g.position.set( 0, 0, 0 ); g.rotation.set( 0, 0, 0 ); } );
        }
      }
      try {
        renderer.render( scene, camera );
      } catch ( e ) {
        console.error( 'Render error', e );
        cancelAnimationFrame( animationId );
        showFallback();
      }
    };

    const cleanup = () => {
      if ( animationId ) cancelAnimationFrame( animationId );
      window.removeEventListener( 'resize', handleResize );
      window.removeEventListener( 'keydown', handleKeydown );
      if ( renderer?.domElement ) {
        renderer.domElement.removeEventListener( 'click', handleClick );
        renderer.domElement.removeEventListener( 'touchstart', handleClick );
      }
      if ( scene ) {
        scene.traverse( o => {
          if ( o.geometry ) o.geometry.dispose();
          if ( o.material ) {
            if ( Array.isArray( o.material ) ) o.material.forEach( m => m.dispose() );
            else o.material.dispose();
          }
        } );
      }
      if ( renderer ) {
        renderer.dispose();
        renderer.domElement?.parentNode?.removeChild( renderer.domElement );
      }
    };

    const init = async () => {
      try {
        scene = new THREE.Scene();
        scene.background = new THREE.Color( config.background.color );
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.z = 20;
        renderer = new THREE.WebGLRenderer( { antialias: true, powerPreference: 'high-performance' } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setPixelRatio( Math.min( window.devicePixelRatio, 2 ) );
        container.appendChild( renderer.domElement );

        scene.add( new THREE.AmbientLight( 0xffffff, 0.7 ) );
        const d = new THREE.DirectionalLight( 0xffffff, 1 );
        d.position.set( 1, 1, 1 ); scene.add( d );
        const accent = new THREE.PointLight( 0x002ea2, 0.8 );
        accent.position.set( 0, 0, 10 ); scene.add( accent );

        createParticles();
        await createText();

        loadingIndicator.style.display = 'none';

        window.addEventListener( 'resize', handleResize );
        renderer.domElement.addEventListener( 'click', handleClick );
        renderer.domElement.addEventListener( 'touchstart', handleClick );
        window.addEventListener( 'keydown', handleKeydown );

        animate();

        // NodeCG integration
        if ( typeof nodecg !== 'undefined' ) {
          const configReplicant = nodecg.Replicant( 'sceneConfig' );
          configReplicant.on( 'change', newVal => {
            if ( newVal ) {
              config = { ...config, ...newVal }; // shallow merge
              // preserve nested defaults if enabled missing
              [ 'title', 'subtitle', 'attribution' ].forEach( k => {
                if ( config[ k ].enabled === undefined ) config[ k ].enabled = true;
              } );
              document.body.style.backgroundColor = setHex( config.background.color );
              setEnabledFallbackVisibility();
              createParticles();
              createText();
            }
          } );
          configReplicant.value = config;

          const explosionReplicant = nodecg.Replicant( 'triggerExplosion' );
          explosionReplicant.on( 'change', v => {
            if ( v && v.trigger ) {
              triggerExplosion();
              setTimeout( () => { explosionReplicant.value = { trigger: false }; }, 100 );
            }
          } );
        }

        console.log( 'Graphics scene ready. Click / key to explode. URL params supported.' );
      } catch ( e ) {
        console.error( 'Init error', e );
        showFallback();
      }
    };

    window.addEventListener( 'beforeunload', cleanup );
    init();
  </script>
</body>

</html>
